# -*- coding: utf-8 -*-
"""predesigned_modules.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1GMzG7by5JejNW9lyRfyhvnQcWNcgCLz5
"""

from torch import nn
from torchvision.models.resnet import BasicBlock, Bottleneck

def default_matching_networks_support_encoder(feature_dimension: int) -> nn.Module:
    return nn.LSTM(
        input_size=feature_dimension,
        hidden_size=feature_dimension,
        num_layers=1,
        batch_first=True,
        bidirectional=True,
    )

def default_matching_networks_query_encoder(feature_dimension: int) -> nn.Module:
    return nn.LSTMCell(feature_dimension * 2, feature_dimension)


def relation_module(feature_dimension: int, inner_channels: int = 1024):
  
  net = nn.Sequential(
      nn.Sequential(                    
            nn.Conv2d(feature_dimension * 2,
                      feature_dimension,
                      kernel_size=3,
                      padding=1,
                      ),
            nn.BatchNorm2d(feature_dimension, momentum=1, affine=True),
            nn.ReLU(inplace=True),
            
            nn.Conv2d(feature_dimension,
                      feature_dimension,
                      kernel_size=3,
                      padding=1,
                      ),
            nn.BatchNorm2d(feature_dimension, momentum=1, affine=True),
            nn.ReLU(inplace=True),
            
            nn.Conv2d(feature_dimension,
                      feature_dimension,
                      kernel_size=3,
                      padding=1,
                      ),
            nn.BatchNorm2d(feature_dimension, momentum=1, affine=True),
            nn.ReLU(inplace=True),
            
            nn.Conv2d(feature_dimension,
                      feature_dimension,
                      kernel_size=3,
                      padding=1,
                      ),
            nn.BatchNorm2d(feature_dimension, momentum=1, affine=True),
            nn.ReLU(inplace=True),
            nn.MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False),
            nn.AdaptiveAvgPool2d(output_size=(7,7))
        ),
    nn.Sequential(
            nn.Flatten(),
            nn.Linear(in_features= 25088, out_features=inner_channels, bias= True),
            nn.Sigmoid(),
            nn.Dropout(p=0.9, inplace= False),
            nn.Linear(in_features= inner_channels, out_features= 1, bias= True),
            nn.Sigmoid(),
  ),
)
  return net

def default_relation_module(feature_dimension: int, inner_channels: int = 8):
    """
    Build the relation module that takes as input the concatenation of two feature maps, from
    Sung et al. : "Learning to compare: Relation network for few-shot learning." (2018)
    In order to make the network robust to any change in the dimensions of the input images,
    we made some changes to the architecture defined in the original implementation
    from Sung et al.(typically the use of adaptive pooling).
    Args:
        feature_dimension: the dimension of the feature space i.e. size of a feature vector
        inner_channels: number of hidden channels between the linear layers of  the relation module

    Returns:
        the constructed relation module
    """
    return nn.Sequential(
        nn.Sequential(
            nn.Conv2d(
                feature_dimension * 2,
                feature_dimension,
                kernel_size=3,
                padding=1,
            ),
            nn.BatchNorm2d(feature_dimension, momentum=1, affine=True),
            nn.ReLU(),
            nn.AdaptiveMaxPool2d((5, 5)),
        ),
        nn.Sequential(
            nn.Conv2d(
                feature_dimension,
                feature_dimension,
                kernel_size=3,
                padding=0,
            ),
            nn.BatchNorm2d(feature_dimension, momentum=1, affine=True),
            nn.ReLU(),
            nn.AdaptiveMaxPool2d((1, 1)),
        ),
        nn.Flatten(),
        nn.Linear(feature_dimension, inner_channels),
        nn.ReLU(),
        nn.Linear(inner_channels, 1),
        nn.Sigmoid(),
    )