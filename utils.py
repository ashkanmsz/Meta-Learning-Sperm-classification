# -*- coding: utf-8 -*-
"""utils.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1MDUc2ZG1WqtnfRObHeJQtmOCSbWUZTFc
"""

"""
General utilities
"""
import torch
import torchvision
from matplotlib import pyplot as plt
from torch import Tensor
import pandas as pd
import openpyxl

def plot_images(images: Tensor, title: str, images_per_row: int):
    """
    Plot images in a grid.
    Args:
        images: 4D mini-batch Tensor of shape (B x C x H x W)
        title: title of the figure to plot
        images_per_row: number of images in each row of the grid
    """
    plt.figure()
    plt.title(title)
    plt.imshow(
        torchvision.utils.make_grid(images, nrow=images_per_row).permute(1, 2, 0)
    )


def compute_prototypes(support_features: Tensor, support_labels: Tensor) -> Tensor:
    """
    Compute class prototypes from support features and labels
    Args:
        support_features: for each instance in the support set, its feature vector
        support_labels: for each instance in the support set, its label

    Returns:
        for each label of the support set, the average feature vector of instances with this label
    """
    n_way = len(torch.unique(support_labels))
    # Prototype i is the mean of all instances of features corresponding to labels == i
    return torch.cat(
        [
            support_features[torch.nonzero(support_labels == label)].mean(0)
            for label in range(n_way)
        ]
    )

def save_result (
       columns = ['Train loss','Val Acc','Test Acc','shot','query','train tasks','valid tasks','test task',
       'train label','valid label','test label', 'model', 'method','learning rate','loss func','precision','recall','dsc'],
       rows = [], 
       path = '/content/drive/MyDrive/Colab Notebooks/sperm/result.xlsx'
      ):
  
  df = pd.read_excel(path)
  new_data = {}
  for i in range(len(columns)):
    new_data[columns[i]] = rows[i]

  df2 = pd.DataFrame(new_data)

  if df.empty :
    df2.to_excel(path)

  else :
    df = pd.concat([df, df2]).reset_index(drop = True)
    df.to_excel(path,columns = columns)
  
def reset_result(path = '/content/drive/MyDrive/Colab Notebooks/sperm/', file_name='result'):
  workbook = openpyxl.load_workbook(path + file_name + '.xlsx')
  sheets = workbook.get_sheet_names()
  std = workbook.get_sheet_by_name(sheets[0])
  workbook.remove_sheet(std)
  workbook.create_sheet()
  workbook.save(path + file_name + '.xlsx')
  print("the file has been deleted successfully!!")


def accuracy(TP, TN, FP, FN):
    return (TP + TN) / (TP + TN + FP + FN)


def precision(TP, FP):
    return TP / (TP + FP)


def recall(TP, FN):
    return TP / (TP + FN)


def dsc(TP, FP, FN):
    return (2 * TP) / (2 * TP + FP + FN)

